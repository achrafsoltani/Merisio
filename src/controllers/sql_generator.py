from typing import List, Tuple
from ..models.project import Project
from ..models.entity import Entity
from ..models.association import Association
from ..models.link import Link


class SQLGenerator:
    """Generates PostgreSQL DDL from MCD model."""

    def __init__(self, project: Project):
        self._project = project

    def generate(self) -> str:
        """Generate complete SQL DDL script."""
        lines = []
        lines.append("-- Generated by AnalyseSI Modern")
        lines.append("-- PostgreSQL DDL")
        lines.append("")

        # Generate tables for entities
        for entity in self._project.get_all_entities():
            table_sql = self._generate_entity_table(entity)
            if table_sql:
                lines.append(table_sql)
                lines.append("")

        # Analyze associations and generate appropriate structures
        for assoc in self._project.get_all_associations():
            assoc_sql = self._generate_association_table(assoc)
            if assoc_sql:
                lines.append(assoc_sql)
                lines.append("")

        return "\n".join(lines)

    def _generate_entity_table(self, entity: Entity) -> str:
        """Generate CREATE TABLE statement for an entity."""
        dictionary = self._project.dictionary
        lines = []
        lines.append(f"CREATE TABLE {self._safe_name(entity.name)} (")

        columns = []
        pk_columns = []

        for attr_name in entity.attributes:
            attr = dictionary.get_attribute(attr_name)
            if attr:
                col_def = f"    {self._safe_name(attr.name)} {attr.get_sql_type()}"
                if attr.is_primary_key:
                    pk_columns.append(self._safe_name(attr.name))
                columns.append(col_def)

        # Check if we need to add foreign keys from 1,1 or 0,1 relationships
        links = self._project.get_links_for_entity(entity.id)
        for link in links:
            if link.cardinality_max == "1":  # This entity has (x,1) cardinality
                # Get the other entity through the association
                assoc_links = self._project.get_links_for_association(link.association_id)
                for other_link in assoc_links:
                    if other_link.entity_id != entity.id and other_link.cardinality_max == "N":
                        # This is a N-1 relationship, add FK to this entity
                        other_entity = self._project.get_entity(other_link.entity_id)
                        if other_entity:
                            fk_columns = self._get_pk_columns(other_entity)
                            for fk_col in fk_columns:
                                attr = dictionary.get_attribute(fk_col)
                                if attr:
                                    col_name = f"fk_{self._safe_name(other_entity.name)}_{fk_col}"
                                    col_def = f"    {col_name} {attr.get_sql_type()}"
                                    columns.append(col_def)
                                    columns.append(
                                        f"    FOREIGN KEY ({col_name}) "
                                        f"REFERENCES {self._safe_name(other_entity.name)}({self._safe_name(fk_col)})"
                                    )

        # Add primary key constraint
        if pk_columns:
            columns.append(f"    PRIMARY KEY ({', '.join(pk_columns)})")

        lines.append(",\n".join(columns))
        lines.append(");")

        return "\n".join(lines)

    def _generate_association_table(self, assoc: Association) -> str:
        """Generate CREATE TABLE for associations that need junction tables."""
        dictionary = self._project.dictionary
        links = self._project.get_links_for_association(assoc.id)

        if len(links) < 2:
            return ""

        # Check if this is a N-N relationship (needs junction table)
        multiple_links = [link for link in links if link.cardinality_max == "N"]

        # Also create junction table if association has carrying attributes
        if len(multiple_links) >= 2 or assoc.has_attributes():
            return self._generate_junction_table(assoc, links)

        return ""

    def _generate_junction_table(self, assoc: Association, links: List[Link]) -> str:
        """Generate a junction table for N-N relationships."""
        dictionary = self._project.dictionary
        lines = []
        table_name = self._safe_name(assoc.name)
        lines.append(f"CREATE TABLE {table_name} (")

        columns = []
        pk_columns = []
        fk_constraints = []

        # Add foreign key columns for each linked entity
        for link in links:
            entity = self._project.get_entity(link.entity_id)
            if entity:
                pk_cols = self._get_pk_columns(entity)
                for pk_col in pk_cols:
                    attr = dictionary.get_attribute(pk_col)
                    if attr:
                        col_name = f"fk_{self._safe_name(entity.name)}_{pk_col}"
                        col_def = f"    {col_name} {attr.get_sql_type()} NOT NULL"
                        columns.append(col_def)
                        pk_columns.append(col_name)
                        fk_constraints.append(
                            f"    FOREIGN KEY ({col_name}) "
                            f"REFERENCES {self._safe_name(entity.name)}({self._safe_name(pk_col)})"
                        )

        # Add carrying attributes
        for attr_name in assoc.attributes:
            attr = dictionary.get_attribute(attr_name)
            if attr:
                col_def = f"    {self._safe_name(attr.name)} {attr.get_sql_type()}"
                columns.append(col_def)

        # Add primary key (composite of all foreign keys)
        if pk_columns:
            columns.append(f"    PRIMARY KEY ({', '.join(pk_columns)})")

        # Add foreign key constraints
        columns.extend(fk_constraints)

        lines.append(",\n".join(columns))
        lines.append(");")

        return "\n".join(lines)

    def _get_pk_columns(self, entity: Entity) -> List[str]:
        """Get primary key column names for an entity."""
        dictionary = self._project.dictionary
        pk_columns = []
        for attr_name in entity.attributes:
            attr = dictionary.get_attribute(attr_name)
            if attr and attr.is_primary_key:
                pk_columns.append(attr_name)
        return pk_columns

    def _safe_name(self, name: str) -> str:
        """Convert name to safe SQL identifier."""
        # Convert to lowercase and replace spaces with underscores
        safe = name.lower().replace(" ", "_").replace("-", "_")
        # Remove any non-alphanumeric characters except underscore
        safe = "".join(c for c in safe if c.isalnum() or c == "_")
        return safe
